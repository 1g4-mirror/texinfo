.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Locale::Recode 3pm"
.TH Locale::Recode 3pm "2018-10-08" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Recode \- Object\-Oriented Portable Charset Conversion
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Locale::Recode;
\&
\&  $cd = Locale::Recode\->new (from => \*(AqUTF\-8\*(Aq,
\&                             to   => \*(AqISO\-8859\-1\*(Aq);
\&
\&  die $cd\->getError if $cd\->getError;
\&
\&  $cd\->recode ($text) or die $cd\->getError;
\&
\&  $mime_name = Locale::Recode\->resolveAlias (\*(Aqlatin\-1\*(Aq);
\&
\&  $supported = Locale::Recode\->getSupported;
\&
\&  $complete = Locale::Recode\->getCharsets;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides routines that convert textual data from one
codeset to another in a portable way.  The module has been started
before \fIEncode\fR\|(3) was written.  It's main purpose today is to provide
charset conversion even when \fIEncode\fR\|(3) is not available on the system.
It should also work for older Perl versions without Unicode support.
.PP
Internally \fILocale::Recode\fR\|(3) will use \fIEncode\fR\|(3) whenever possible,
to allow for a faster conversion and for a wider range of supported
charsets, and will only fall back to the Perl implementation when
\&\fIEncode\fR\|(3) is not available or does not support a particular charset
that \fILocale::Recode\fR\|(3) does.
.PP
\&\fILocale::Recode\fR\|(3) is part of libintl-perl, and it's main purpose is
actually to implement a portable charset conversion framework for
the message translation facilities described in \fILocale::TextDomain\fR\|(3).
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
The constructor \f(CW\*(C`new()\*(C'\fR requires two named arguments:
.IP "\fBfrom\fR" 4
.IX Item "from"
The encoding of the original data.  Case doesn't matter, aliases
are resolved.
.IP "\fBto\fR" 4
.IX Item "to"
The target encoding.  Again, case doesn't matter, and aliases
are resolved.
.PP
The constructor will never fail.  In case of an error, the object's
internal state is set to bad and it will refuse to do any conversions.
You can inquire the reason for the failure with the method
\&\fIgetError()\fR.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
The following object methods are available.
.IP "\fBrecode (\s-1STRING\s0)\fR" 4
.IX Item "recode (STRING)"
Converts \fB\s-1STRING\s0\fR from the source encoding into the destination
encoding.  In case of success, a truth value is returned, false
otherwise.  You can inquire the reason for the failure with the
method \fIgetError()\fR.
.IP "\fBgetError\fR" 4
.IX Item "getError"
Returns either false if the object is not in an error state or
an error message.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
The object provides some additional class methods:
.IP "\fBgetSupported\fR" 4
.IX Item "getSupported"
Returns a reference to a list of all supported charsets.  This
may implicitely load additional \fIEncode\fR\|(3) conversions like 
\&\fIEncode::HanExtra\fR\|(3) which may produce considerable load on your
system.
.Sp
The method is therefore not intended for regular use but rather
for getting resp. displaying \fIonce\fR a list of available encodings.
.Sp
The members of the list are all converted to uppercase!
.IP "\fBgetCharsets\fR" 4
.IX Item "getCharsets"
Like \fIgetSupported()\fR but also returns all available aliases.
.SH "SUPPORTED CHARSETS"
.IX Header "SUPPORTED CHARSETS"
The range of supported charsets is system-dependent.  The following
somewhat special charsets are always available:
.IP "\fB\s-1UTF\-8\s0\fR" 4
.IX Item "UTF-8"
\&\s-1UTF\-8\s0 is available independently of your Perl version.  For Perl 5.6
or better or in the presence of \fIEncode\fR\|(3), conversions are not done
in Perl but with the interfaces provided by these facilities which
are written in C, hence much faster.
.Sp
Encoding data \fIinto\fR \s-1UTF\-8\s0 is fast, even if it is done in Perl.
Decoding it in Perl may become quite slow.  If you frequently have
to decode \s-1UTF\-8\s0 with \fBLocale::Recode\fR you will probably want to
make sure that you do that with Perl 5.6 or beter, or install \fIEncode\fR\|(3) to
speed up things.
.IP "\fB\s-1INTERNAL\s0\fR" 4
.IX Item "INTERNAL"
\&\s-1UTF\-8\s0 is fast to write but hard to read for applications.  It is 
therefore not the worst for internal string representation but not
far from that.  \fILocale::Recode\fR\|(3) stores strings internally as a
reference to an array of integer values like most programming languages
(Perl is an exception) do, trading memory for performance.
.Sp
The integer values are the \s-1UCS\-4\s0 codes of the characters in host
byte order.
.Sp
The encoding \fB\s-1INTERNAL\s0\fR is directly availabe via \fILocale::Recode\fR\|(3)
but of course you should not really use it for data exchange, unless
you know what you are doing.
.PP
\&\fILocale::Recode\fR\|(3) has native support for a plethora of other encodings,
most of them 8 bit encodings that are fast to decode, including most
encodings used on popular micros like the ISO\-8859\-* series of encodings,
most Windows\-* encodings (also known as CP*), Macintosh, Atari, etc.
.SH "NAMES AND ALIASES"
.IX Header "NAMES AND ALIASES"
Each charset resp. encoding is available internally under a unique
name.  Whenever the information was available, the preferred \s-1MIME\s0 name
(see <http://www.iana.org/assignments/character\-sets/>) was chosen as 
the internal name.
.PP
Alias handling is quite strict.  The module does not make wild guesses
at what you mean (\*(L"What's the meaning of the acronym \s-1JIS\*(R"\s0 is a valid
alias for \*(L"7bit\-jis\*(R" in \fIEncode\fR\|(3) ....) but aims at providing common
aliases only.  The same applies to so-called aliases that are really 
mistakes, like \*(L"utf8\*(R" for \s-1UTF\-8.\s0
.PP
The module knows all aliases that are listed with the \s-1IANA\s0 character
set registry (<http://www.iana.org/assignments/character\-sets/>), plus
those known to libiconv version 1.8, and a bunch of additional ones.
.SH "CONVERSION TABLES"
.IX Header "CONVERSION TABLES"
The conversion tables have either been taken from official sources
like the \s-1IANA\s0 or the Unicode Consortium, from Bruno Haible's libiconv,
or from the sources of the \s-1GNU\s0 libc and the regression tests for 
libintl-perl will check for conformance here.  For some encodings this data
differs from \fIEncode\fR\|(3)'s data which would cause these tests to fail.  
In these cases, the module will not invoke the \fIEncode\fR\|(3) methods, but
will fall back to the internal implementation for the sake of 
consistency.
.PP
The few encodings that are affected are so simple that you will not
experience any real performance penalty unless you convert large chunks
of data.  But the package is not really intended for such use anyway, and
since \fIEncode\fR\|(3) is relatively new, I rather think that the differences
are bugs in Encode which will be fixed soon.
.SH "BUGS"
.IX Header "BUGS"
The module should provide fall back conversions for other Unicode
encoding schemes like \s-1UCS\-2, UCS\-4\s0 (big\- and little-endian).
.PP
The pure Perl \s-1UTF\-8\s0 decoder will not always handle corrupt \s-1UTF\-8\s0
correctly, especially at the end and at the beginning of the string.
This is not likely to be fixed, since the module's intention is not
to be a consistency checker for \s-1UTF\-8\s0 data.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) 2002\-2017 Guido Flohr <http://www.guido-flohr.net/>
(<mailto:guido.flohr@cantanea.com>), all rights reserved.  See the source
code for details!code for details!
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIEncode\fR\|(3), \fIiconv\fR\|(3), \fIiconv\fR\|(1), \fIrecode\fR\|(1), \fIperl\fR\|(1)
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 365:" 4
.IX Item "Around line 365:"
=cut found outside a pod block.  Skipping to next block.
