<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg">
  <head>
    <title>Partial application</title>
    <link rel="stylesheet" type="text/css" href="docbook-epub.css"/>
    <link rel="stylesheet" type="text/css" href="kawa.css"/>
    <script src="kawa-ebook.js" type="text/javascript"/>
    <meta name="generator" content="DocBook XSL-NS Stylesheets V1.79.1"/>
    <link rel="prev" href="Overall-Index.xhtml" title="Index"/>
    <link rel="next" href="Numbers.xhtml" title="Quantities and Numbers"/>
  </head>
  <body>
    <header/>
    <section class="sect1" title="Partial application" epub:type="subchapter" id="Partial-application">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both">Partial application</h2>
          </div>
        </div>
      </div>
      <p class="synopsis" kind="Syntax"><span class="kind">Syntax</span><span class="ignore">: </span><a id="idm139667877251776" class="indexterm"/> <code class="function">cut</code> <em class="replaceable"><code>slot-or-expr</code></em> <em class="replaceable"><code>slot-or-expr*</code></em> [<em class="replaceable"><code>&lt;...&gt;</code></em>]</p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <p>where each <em class="replaceable"><code>slot-or-expr</code></em> is either an <em class="replaceable"><code>expression</code></em> or
the literal symbol <code class="literal">&lt;&gt;</code>.
</p>
          <p>It is frequently necessary to specialize some of the parameters of a
multi-parameter procedure. For example, from the binary operation <code class="literal">cons</code>
one might want to obtain the unary operation
<code class="literal">(lambda (x) (cons 1 x))</code>.
This specialization of parameters is also known
as <em class="firstterm">partial application</em>, <em class="firstterm">operator section</em>, or <em class="firstterm">projection</em>.
The macro <code class="literal">cut</code> specializes some of the parameters of its first
argument. The parameters that are to show up as formal variables of the
result are indicated by the symbol <code class="literal">&lt;&gt;</code>, pronouced as "slot".
In addition, the symbol <code class="literal">&lt;...&gt;</code>, pronounced as "rest-slot", matches all
residual arguments of a variable argument procedure.
</p>
          <p>A <code class="literal">cut</code>-expression is transformed into
a <em class="replaceable"><code>lambda expression</code></em> with as many formal variables as there are
slots in the list <em class="replaceable"><code>slot-or-expr</code></em>*.
The body of the resulting <em class="replaceable"><code>lambda expression</code></em> calls
the first <em class="replaceable"><code>slot-or-expr</code></em> with arguments from the <em class="replaceable"><code>slot-or-expr</code></em>* list
in the order they appear. In case there is a rest-slot symbol, the resulting
procedure is also of variable arity, and the body calls the first
<em class="replaceable"><code>slot-or-expr</code></em> with remaining arguments provided to the actual call of the
specialized procedure.
</p>
          <p>Here are some examples:
</p>
          <p><code class="literal">(cut cons (+ a 1) &lt;&gt;)</code> is the same as <code class="literal">(lambda (x2) (cons (+ a 1) x2))</code>
</p>
          <p><code class="literal">(cut list 1 &lt;&gt; 3 &lt;&gt; 5)</code> is the same as <code class="literal">(lambda (x2 x4) (list 1 x2 3 x4 5))</code>
</p>
          <p><code class="literal">(cut list)</code> is the same as <code class="literal">(lambda () (list))</code>
</p>
          <p><code class="literal">(cut list 1 &lt;&gt; 3 &lt;...&gt;)</code> is the same as <code class="literal">(lambda (x2 . xs) (apply list 1 x2 3 xs))</code>
</p>
          <p>The first argument can also be a slot, as one should expect in Scheme:
<code class="literal">(cut &lt;&gt; a b)</code> is the same as <code class="literal">(lambda (f) (f a b))</code>
</p>
        </blockquote>
      </div>
      <p class="synopsis" kind="Syntax"><span class="kind">Syntax</span><span class="ignore">: </span><a id="idm139667877230688" class="indexterm"/> <code class="function">cute</code> <em class="replaceable"><code>slot-or-expr</code></em> <em class="replaceable"><code>slot-or-expr*</code></em> [<em class="replaceable"><code>&lt;...&gt;</code></em>]</p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <p>The macro <code class="literal">cute</code> (a mnemonic for "cut with evaluated non-slots") is
similar to <code class="literal">cut</code>, but it evaluates the non-slot expressions at the
time the procedure is specialized, not at the time the specialized
procedure is called.
</p>
          <p>For example
<code class="literal">(cute cons (+ a 1) &lt;&gt;)</code> is the same as
<code class="literal">(let ((a1 (+ a 1))) (lambda (x2) (cons a1 x2)))</code>
</p>
          <p>As you see from comparing this example with the first example above, the
<code class="literal">cute</code>-variant will evaluate <code class="literal">(+ a 1)</code> once,
while the <code class="literal">cut</code>-variant will
evaluate it during every invocation of the resulting procedure.
</p>
        </blockquote>
      </div>
    </section>
    <footer>
      <div class="navfooter">
        <p>
          Up: <a accesskey="u" href="Procedures.xhtml">Procedures</a></p>
        <p>
        Previous: <a accesskey="p" href="Extended-formals.xhtml">Extended Formal Arguments List</a></p>
      </div>
    </footer>
  </body>
</html>
