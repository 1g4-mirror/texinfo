<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg">
  <head>
    <title>Importing from a library</title>
    <link rel="stylesheet" type="text/css" href="docbook-epub.css"/>
    <link rel="stylesheet" type="text/css" href="kawa.css"/>
    <script src="kawa-ebook.js" type="text/javascript"/>
    <meta name="generator" content="DocBook XSL-NS Stylesheets V1.79.1"/>
    <link rel="prev" href="Module-classes.xhtml" title="Modules and how they are compiled to classes"/>
    <link rel="next" href="Record-types.xhtml" title="Record types"/>
  </head>
  <body>
    <header/>
    <section class="sect1" title="Importing from a library" epub:type="subchapter" id="Importing">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both">Importing from a library</h2>
          </div>
        </div>
      </div>
      <span id="require"/>
      <p>You can import a module into the current namespace with <code class="literal">import</code> or <code class="literal">require</code>.  This adds the exported bindings (or a subset of them) to the
current lexical scope.  It follows that these bindings (which are said
to be imported) are determined at compile-time.
</p>
      <span id="meta-import-declaration"/>
      <p class="synopsis" kind="Syntax"><span class="kind">Syntax</span><span class="ignore">: </span><a id="idm139667871383728" class="indexterm"/> <code class="function">import</code> <em class="replaceable"><code><a class="link" href="Importing.xhtml#meta-import-set"><em class="replaceable"><code>import-set</code></em></a></code></em><em class="replaceable"><code><sup>*</sup></code></em></p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <p>An <code class="literal">import</code> declaration provides a way to import identifiers
exported by a library (module). Each <em class="replaceable"><code>import-set</code></em> names a set of
bindings from a library and possibly specifies local names
for the imported bindings.
</p>
          <div class="literallayout">
            <p><a id="idm139667871378560" class="indexterm"/><span id="meta-import-set"/><em class="replaceable"><code>import-set</code></em> <code class="literal">::=</code><br/>
    <em class="replaceable"><code>classname</code></em><br/>
  | <a class="link" href="Importing.xhtml#meta-library-reference"><em class="replaceable"><code>library-reference</code></em></a><br/>
  | <code class="literal"><span class="bold"><strong>(library</strong></span></code> <a class="link" href="Importing.xhtml#meta-library-reference"><em class="replaceable"><code>library-reference</code></em></a> <code class="literal"><span class="bold"><strong>)</strong></span></code><br/>
  | <code class="literal"><span class="bold"><strong>(class</strong></span></code> <em class="replaceable"><code>class-prefix</code></em> <em class="replaceable"><code>import-only-name</code></em><sup>*</sup><code class="literal"><span class="bold"><strong>)</strong></span></code><br/>
  | <code class="literal"><span class="bold"><strong>(only</strong></span></code> <a class="link" href="Importing.xhtml#meta-import-set"><em class="replaceable"><code>import-set</code></em></a> <em class="replaceable"><code>import-only-name</code></em><sup>*</sup><code class="literal"><span class="bold"><strong>)</strong></span></code><br/>
  | <code class="literal"><span class="bold"><strong>(except</strong></span></code> <a class="link" href="Importing.xhtml#meta-import-set"><em class="replaceable"><code>import-set</code></em></a> <em class="replaceable"><code>identifier</code></em><sup>*</sup><code class="literal"><span class="bold"><strong>)</strong></span></code><br/>
  | <code class="literal"><span class="bold"><strong>(prefix</strong></span></code> <a class="link" href="Importing.xhtml#meta-import-set"><em class="replaceable"><code>import-set</code></em></a> <em class="replaceable"><code>identifier</code></em> <code class="literal"><span class="bold"><strong>)</strong></span></code><br/>
  | <code class="literal"><span class="bold"><strong>(rename</strong></span></code> <a class="link" href="Importing.xhtml#meta-import-set"><em class="replaceable"><code>import-set</code></em></a> <a class="link" href="Importing.xhtml#meta-rename-pair"><em class="replaceable"><code>rename-pair</code></em></a><sup>*</sup><code class="literal"><span class="bold"><strong>)</strong></span></code><br/>
<a id="idm139667871358032" class="indexterm"/><span id="meta-library-reference"/><em class="replaceable"><code>library-reference</code></em> <code class="literal">::=</code> <code class="literal"><span class="bold"><strong>(</strong></span></code> <a class="link" href="Module-classes.xhtml#meta-library-name-parts"><em class="replaceable"><code>library-name-parts</code></em></a> [<a class="link" href="Importing.xhtml#meta-explicit-source-name"><em class="replaceable"><code>explicit-source-name</code></em></a>]<code class="literal"><span class="bold"><strong>)</strong></span></code><br/>
<a id="idm139667871352832" class="indexterm"/><span id="meta-import-only-name"/><em class="replaceable"><code>import-only-name</code></em> <code class="literal">::=</code> <em class="replaceable"><code>identifier</code></em>|<a class="link" href="Importing.xhtml#meta-rename-pair"><em class="replaceable"><code>rename-pair</code></em></a><br/>
<a id="idm139667871349616" class="indexterm"/><span id="meta-explicit-source-name"/><em class="replaceable"><code>explicit-source-name</code></em> <code class="literal">::=</code> <a class="link" href="String-literals.xhtml#meta-string"><em class="replaceable"><code>string</code></em></a><br/>
<a id="idm139667871346800" class="indexterm"/><span id="meta-rename-pair"/><em class="replaceable"><code>rename-pair</code></em> <code class="literal">::=</code> <code class="literal"><span class="bold"><strong>(</strong></span></code> <em class="replaceable"><code>identifier</code></em><sub>1</sub> <em class="replaceable"><code>identifier</code></em><sub>2</sub><code class="literal"><span class="bold"><strong>)</strong></span></code><br/>
</p>
          </div>
          <p>A <em class="replaceable"><code>library-reference</code></em> is mapped to a class name by concatenating
all the identifiers, separated by dots.
For example:
</p>
          <pre class="screen">(import (gnu kawa slib srfi37))
</pre>
          <p>is equivalent to:
</p>
          <pre class="screen">(import gnu.kawa.slib.srfi37)
</pre>
          <p>as well as to:
</p>
          <pre class="screen">(require gnu.kawa.slib.srfi37)
</pre>
          <p>By default, all of an imported library’s exported bindings are made
visible within an importing library using the names given to the
bindings by the imported library.  The precise set of bindings to be
imported and the names of those bindings can be adjusted with the
<code class="literal">only</code>, <code class="literal">except</code>, <code class="literal">prefix</code>, and <code class="literal"> rename</code> forms as
described below.
</p>
          <div class="itemizedlist" epub:type="list">
            <ul style="list-style-type: disc; " class="itemizedlist">
              <li class="listitem" epub:type="list-item">
                <p>An <code class="literal">only</code> form produces a subset of the bindings from another
<em class="replaceable"><code>import-set</code></em>, including only the listed <em class="replaceable"><code>identifier</code></em>s.  The
included <em class="replaceable"><code>identifier</code></em>s must be in the original <em class="replaceable"><code>import-set</code></em>.
If a <em class="replaceable"><code>rename-pair</code></em> is used, then the <code class="literal"><em class="replaceable"><code>identifier</code></em><sub>1</sub></code>
must be in the original <em class="replaceable"><code>import-set</code></em>,
and is renamed to <code class="literal"><em class="replaceable"><code>identifier</code></em><sub>2</sub></code>.  For example:
</p>
                <pre class="screen">(import (only (kawa example) A (B1 B2) C (D1 D2)))
</pre>
                <p>is equivalent to:
</p>
                <pre class="screen">(import (rename (only (kawa example) A B1 C D1)
                (B1 B2) (D1 D2)))
</pre>
                <p>The names <code class="literal">A</code>, <code class="literal">B1</code>, <code class="literal">C</code>, and <code class="literal">D1</code> must
exist in the library <code class="literal">(kawa example)</code>.  The bindings are
accessible using the names <code class="literal">A</code>, <code class="literal">B2</code>, <code class="literal">C</code>, and <code class="literal">D2</code>.
</p>
              </li>
              <li class="listitem" epub:type="list-item">
                <p>An <code class="literal">except</code> form produces a subset of the bindings from another
<em class="replaceable"><code>import-set</code></em>, including all but the listed <em class="replaceable"><code>identifier</code></em>s.  All
of the excluded <em class="replaceable"><code>identifier</code></em>s must be in the original <em class="replaceable"><code>import-set</code></em>.
</p>
              </li>
              <li class="listitem" epub:type="list-item">
                <p>A <code class="literal">prefix</code> form adds the <em class="replaceable"><code>identifier</code></em> prefix to each name from
another <em class="replaceable"><code>import-set</code></em>.
</p>
              </li>
              <li class="listitem" epub:type="list-item">
                <p>A <code class="literal">rename</code> form:
</p>
                <pre class="screen">(rename (<em class="replaceable"><code>identifier</code></em><sub>1</sub> <em class="replaceable"><code>identifier</code></em><sub>2</sub>) …)
</pre>
                <p>removes the bindings for <code class="literal"><em class="replaceable"><code>identifier</code></em><sub>1</sub> …</code> to form an
intermediate <em class="replaceable"><code>import-set</code></em>, then adds the bindings back for the
corresponding <code class="literal"><em class="replaceable"><code>identifier</code></em><sub>2</sub> …</code> to form the final
<em class="replaceable"><code>import-set</code></em>.  Each <code class="literal"><em class="replaceable"><code>identifier</code></em><sub>1</sub></code> must be in the original
<em class="replaceable"><code>import-set</code></em>, each <em class="replaceable"><code>identifier</code></em><sub>2</sub> must not be in the
intermediate <em class="replaceable"><code>import-set</code></em>, and the <em class="replaceable"><code>identifier</code></em><sub>2</sub>s must be
distinct.
</p>
              </li>
            </ul>
          </div>
          <p>A <code class="literal">class</code> form is a convenient way to define abbreviations
for class names; it may be more convenient than <code class="literal">define-alias</code>.
The <em class="replaceable"><code>class-prefix</code></em> is concatenated with each <em class="replaceable"><code>identifier</code></em>
(with a period in between) to produce a classname.
Each <em class="replaceable"><code>identifier</code></em> becomes an alias for the class.
For example:
</p>
          <pre class="screen">(import (class java.util Map (HashMap HMap)))
</pre>
          <p>This defines <code class="literal">Map</code> as an alias for <code class="literal">java.util.Map</code>,
and <code class="literal">HMap</code> as an alias for <code class="literal">java.util.HashMap</code>.
(You can think of the <code class="literal">class</code> form as similar to a <code class="literal">only</code> form,
where the <em class="replaceable"><code>class-prefix</code></em> names a special kind of
library represented of a Java package, and whose exported
bindings are the classes in the package.)
</p>
          <p>You can combine the <code class="literal">class</code> form with
<code class="literal">only</code>, <code class="literal">except</code>, <code class="literal">rename</code>, and <code class="literal">prefix</code>,
though only <code class="literal">prefix</code> is likely to be useful.  For example:
</p>
          <pre class="screen">(import (prefix (class java.lang Long Short) jl-))
</pre>
          <p>is equivalent to
</p>
          <pre class="screen">(import (class java.lang (Long jl-Long) (Short jl-Short)))
</pre>
          <p>which is equivalent to:
</p>
          <pre class="screen">(define-private-alias jl-Short java.lang.Short)
(define-private-alias jl-Long java.lang.Long)
</pre>
        </blockquote>
      </div>
      <p class="synopsis" kind="Syntax"><span class="kind">Syntax</span><span class="ignore">: </span><a id="idm139667871301104" class="indexterm"/> <code class="function">require</code> <em class="replaceable"><code><span class="bold"><strong>’</strong></span></code></em><em class="replaceable"><code>featureName</code></em></p>
      <p class="synopsis" kind="Syntax"><span class="kind">Syntax</span><span class="ignore">: </span><a id="idm139667871297584" class="indexterm"/> <code class="function">require</code> <em class="replaceable"><code>classname</code></em> [<em class="replaceable"><code><a class="link" href="Importing.xhtml#meta-explicit-source-name"><em class="replaceable"><code>explicit-source-name</code></em></a></code></em>]</p>
      <p class="synopsis" kind="Syntax"><span class="kind">Syntax</span><span class="ignore">: </span><a id="idm139667871293664" class="indexterm"/> <code class="function">require</code> <em class="replaceable"><code><a class="link" href="Importing.xhtml#meta-explicit-source-name"><em class="replaceable"><code>explicit-source-name</code></em></a></code></em>]</p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <p>Search for a matching module (class), and add the names
exported by that module to the current set of visible names.
Normally, the module is specified using <em class="replaceable"><code>classname</code></em>.
</p>
          <p>The form <code class="literal">require</code> has similar functionality as <code class="literal">import</code>,
but with a different syntax, and without options like <code class="literal">rename</code>.
</p>
          <p>If a <code class="literal"><code class="literal"><span class="bold"><strong>"</strong></span></code><em class="replaceable"><code>sourcepath</code></em><code class="literal"><span class="bold"><strong>"</strong></span></code></code> is specified then
that is used to locate the source file for the module, and if necessary,
compile it.
</p>
          <p>If a <code class="literal">'<em class="replaceable"><code>featurename</code></em></code> is specified then the
<em class="replaceable"><code>featurename</code></em> is looked up (at compile time) in the "feature table"
which yields the implementing <em class="replaceable"><code>classname</code></em>.
</p>
        </blockquote>
      </div>
      <p class="synopsis" kind="Syntax"><span class="kind">Syntax</span><span class="ignore">: </span><a id="idm139667871282608" class="indexterm"/> <code class="function">provide</code> <em class="replaceable"><code><span class="bold"><strong>’</strong></span></code></em><em class="replaceable"><code>featurename</code></em></p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <p>Declare that <code class="literal">'<em class="replaceable"><code>featurename</code></em></code> is available.
A following <code class="literal">cond-expand</code> in this scope will match <em class="replaceable"><code>featurename</code></em>.
</p>
        </blockquote>
      </div>
      <p>Using <code class="literal">require</code> and <code class="literal">provide</code> with <em class="replaceable"><code>featurename</code></em>s is
similar to the same-named macros in SLib, Emacs, and Common Lisp.
However, in Kawa these are not functions, but instead they
are syntax forms that are processed at compile time.  That is
why only quoted <em class="replaceable"><code>featurename</code></em>s are supported.
This is consistent with Kawa emphasis on compilation and
static binding.
</p>
      <p>For some examples, you may want to look in the <code class="literal">gnu/kawa/slib</code>
directory.
</p>
      <section class="sect2" title="Searching for modules" epub:type="division" id="idm139667871273696">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title">Searching for modules</h3>
            </div>
          </div>
        </div>
        <p>When Kawa sees a <code class="literal">import</code> or <code class="literal">require</code> it searches for
either a matching source file or a previously-compiled class with a
matching name.
</p>
        <p>For <code class="literal">import</code> we generate a classname by converting it in the same
way <code class="literal">module-name</code> does:  taking each identifier in the
<em class="replaceable"><code>library-name-parts</code></em>, mangling if needed, and concatenating the parts
separated by periods.
</p>
        <p>If there is a matching module in any <em class="replaceable"><code>program-unit</code></em> that is
in the process of being compiled, we use that.  This may be
a file requested to be compiled with the <code class="literal">-C</code> command-line switch,
or an extra <em class="replaceable"><code>library-definition</code></em> in a file already parsed.
Kawa will attempt to finish compiling the module and load the class,
but if there are circular dependencies it will use the uncompiled definitions.
</p>
        <p>Next Kawa looks for a matching class in the context classpath.
(There is special handling if the library-name starts with <code class="literal">srfi</code>,
and certain builtin classes will have <code class="literal">kawa.lib.</code> prepended.)
</p>
        <p>Kawa also searches for a matching source file, described below.
It uses the implicit source name (formed by concatenating the
library-name parts, separated by <code class="literal">"/"</code>), as well as
any <em class="replaceable"><code>explicit-source-name</code></em>.  The source file is parsed as
a <a class="link" href="Bodies.xhtml#meta-program-unit"><em class="replaceable"><code>program-unit</code></em></a>.  It is an error if the <em class="replaceable"><code>program-unit</code></em>
does not declare a library (explicit or implicit) with the
matching name.
</p>
        <p>If Kawa finds both a matching source file and a class, it will pick one
based on which is newer.
</p>
      </section>
      <section class="sect2" title="Searching for source files" epub:type="division" id="idm139667871262528">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title">Searching for source files</h3>
            </div>
          </div>
        </div>
        <p>The Java property <code class="literal">kawa.import.path</code> controls how <code class="literal">import</code>
and <code class="literal">require</code> search for a suitable source file.  Example usage:
</p>
        <pre class="screen">$ kawa -Dkawa.import.path=".:&lt;foo fo&gt;/opt/fo-libs/*.scm:/usr/local/kawa"
</pre>
        <p>The value of the <code class="literal">kawa.import.path</code> property is a list of
path elements, separated by <code class="literal">":"</code>.
Each path element is combined with either the explicit source name
or the implicit source name to produce a filename.
If a matching file exists, then we have found a source file.
</p>
        <p>If a path element contains a <code class="literal">"*"</code> then the <code class="literal">"*"</code>
is replaced by the implicit source name (without an extension).
(Any explicit source name is ignored in this case.)
For example, for <code class="literal">(import (foo bar))</code> or <code class="literal">(require foo.bar)</code>
the implicit source name is <code class="literal">"foo/bar"</code>.  If the path element is
<code class="literal">"/opt/kawa/*.sc"</code> then the resulting filename is <code class="literal">"/opt/kawa/foo/bar.sc"</code>.
</p>
        <p>If there is no <code class="literal">"*"</code> in the path element, and there is an
explicit source, then it is appended to the path element
(or replaces the path element if the explicit source is absolute).
Otherwise we use the implicit source, followed by the default file extension.
(The default file extension is that of the current source if that is a
named file; otherwise the default for the current language, which
is <code class="literal">".scm"</code>  for Scheme.)
</p>
        <p>A path element that starts with a selector of the
form <code class="literal">"&lt;<a class="link" href="Module-classes.xhtml#meta-library-name-parts"><em class="replaceable"><code>library-name-parts</code></em></a>&gt;"</code> is only applicable if a prefix
of the requested module name matches the <em class="replaceable"><code>library-name-parts</code></em>.  If there
is <code class="literal">"*"</code> in the path element, that is replaced by the corresponding rest
of the implicit source name. For example if importing <code class="literal">(fee fo foo fum</code>)
and the path element is <code class="literal">"&lt;fee fo&gt;/opt/fo-libs/*.scm"</code> then the
resulting filename is <code class="literal">"/opt/fo-libs/foo/fum.scm"</code>.
If there is a selector but no <code class="literal">"*"</code>, then the rest of the path element
following the selector is combined with the explicit or implicit source
as if there were no selector (assuming of course that the selector matches).
</p>
        <p>If the resulting filename is relative, then it is resolved
relative to the <em class="firstterm">current root</em>.  For example the source to
a library with the name <code class="literal">(x y)</code> that compiles to
a class <code class="literal">x.y</code> might be a  file named <code class="literal">/a/b/x/y.scm</code>.
Then the current root would be <code class="literal">/a/b/</code>
- that is the directory that results from removing the library name
suffix from the file name.
</p>
        <p>More generally: assume the current module has <span class="mathphrase">N</span> name components.
For example the name <code class="literal">(x y)</code>
(with the class name <code class="literal">x.y</code>) has 2 components.
The current root is what you get when you take the current file name
(say <code class="literal">"/a/b/c/d.scm"</code>), and remove everything after
the <span class="mathphrase">N</span>’th slash (<code class="literal">"/"</code>) from the end (say <code class="literal">"c/d.scm"</code>;
what remains (e.g. <code class="literal">"/a/b/"</code> is the current root.
(If the current input source is not a named file,
use the value of <code class="literal">(current-path)</code> with a <code class="literal">"/"</code> appended.)
</p>
        <p>The default search path is <code class="literal">"."</code> - i.e. just search relative
to the current root.
</p>
      </section>
      <section class="sect2" title="Builtin libraries" epub:type="division" id="idm139667871238240">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title">Builtin libraries</h3>
            </div>
          </div>
        </div>
        <p>The following libraries are bundled with Kawa:
</p>
        <div class="variablelist" epub:type="list">
          <dl class="variablelist">
            <dt class="term"><code class="literal">(scheme base)</code>
</dt>
            <dt class="term"><code class="literal">(scheme case-lambda)</code>
</dt>
            <dt class="term"><code class="literal">(scheme char)</code>
</dt>
            <dt class="term"><code class="literal">(scheme complex)</code>
</dt>
            <dt class="term"><code class="literal">(scheme cxr)</code>
</dt>
            <dt class="term"><code class="literal">(scheme cxr)</code>
</dt>
            <dt class="term"><code class="literal">(scheme eval)</code>
</dt>
            <dt class="term"><code class="literal">(scheme inexact)</code>
</dt>
            <dt class="term"><code class="literal">(scheme lazy)</code>
</dt>
            <dt class="term"><code class="literal">(scheme load)</code>
</dt>
            <dt class="term"><code class="literal">(scheme process-context)</code>
</dt>
            <dt class="term"><code class="literal">(scheme read)</code>
</dt>
            <dt class="term"><code class="literal">(scheme repl)</code>
</dt>
            <dt class="term"><code class="literal">(scheme time)</code>
</dt>
            <dt class="term"><code class="literal">(scheme write)</code>
</dt>
            <dt class="term"><code class="literal">(scheme r5rs)</code>
</dt>
            <dd>
              <p>The above are standard libraries as defined by R7RS.
</p>
            </dd>
            <dt class="term"><code class="literal">(rnrs arithmetic bitwise)</code>
</dt>
            <dt class="term"><code class="literal">(rnrs hashtables)</code>
</dt>
            <dt class="term"><code class="literal">(rnrs lists)</code>
</dt>
            <dt class="term"><code class="literal">(rnrs programs)</code>
</dt>
            <dt class="term"><code class="literal">(rnrs sorting)</code>
</dt>
            <dt class="term"><code class="literal">(rnrs unicode)</code>
</dt>
            <dd>
              <p>The above are standard libraries as defined by R6RS.
</p>
            </dd>
            <dt class="term"><code class="literal">(kawa reflect)</code>
</dt>
            <dd>
              <p>Defines procedures and syntax for acessing Java objects and members:
  <code class="literal">as</code>
  <code class="literal">field</code>
  <code class="literal">instance?</code>
  <code class="literal">invoke</code>
  <code class="literal">invoke-static</code>
  <code class="literal">invoke-special</code>
  <code class="literal">make</code>
  <code class="literal">primitive-throw</code>
  <code class="literal">set-field!</code>
  <code class="literal">set-static-field!</code>
  <code class="literal">static-field</code>
</p>
            </dd>
            <dt class="term"><code class="literal">(kawa expressions)</code>
</dt>
            <dt class="term"><code class="literal">(kawa hashtable)</code>
</dt>
            <dt class="term"><code class="literal">(kawa quaternions)</code>
</dt>
            <dt class="term"><code class="literal">(kawa rotations)</code>
</dt>
            <dt class="term"><code class="literal">(kawa regex)</code>
</dt>
            <dt class="term"><code class="literal">(kawa string-cursors)</code>
</dt>
            <dd>
              <p>Various Kawa libraries <span class="emphasis"><em>add details</em></span>.
</p>
            </dd>
            <dt class="term"><code class="literal">(kawa base)</code>
</dt>
            <dd>
              <p>All the bindings by default available to the kawa top-level.
</p>
            </dd>
          </dl>
        </div>
      </section>
      <section class="sect2" title="Importing a SRFI library" epub:type="division" id="idm139667871212272">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title">Importing a SRFI library</h3>
            </div>
          </div>
        </div>
        <p>Importing a supported SRFI numbered <em class="replaceable"><code>N</code></em> is conventionally
doing using a <code class="literal">(import (srfi <em class="replaceable"><code>N</code></em>))</code>
or the older R6RS syntax <code class="literal">(import (srfi :<em class="replaceable"><code>N</code></em>))</code> (with a colon, for historical reasons).  You can also give it
a name, as specified by <a class="ulink" href="http://srfi.schemers.org/srfi-95/srfi-95.html" target="_top">SRFI 95</a>. For example, any of these work:
</p>
        <pre class="screen">(import (srfi 95))
(import (srfi 95 sorting-and-merging))
(import (srfi :95))
(import (srfi :95 sorting-and-merging))
</pre>
        <p>You can also use <code class="literal">(require 'srfi-<em class="replaceable"><code>N</code></em>)</code>:
</p>
        <pre class="screen">(require 'srfi-95)
</pre>
      </section>
      <section class="sect2" title="Importing from a plain class" epub:type="division" id="idm139667871206048">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title">Importing from a plain class</h3>
            </div>
          </div>
        </div>
        <p>Note you can import from many classes, even if they weren’t
compiled from a library-definition.  The set of <code class="literal">public</code> fields
in a class are considered as the set of exported definitions,
with the names demangled as needed.
</p>
        <p>The module can be static module (all public fields must be static),
or an instance module (it has a public default constructor).
</p>
        <p>If an imported definition is a non-static field and if no module
instance for that class
has been registered in the current environment, then a new instance
is created and registered (using a "magic" identifier).
If the module class either inherits from <code class="literal">gnu.expr.ModuleBody</code>
or implements <code class="literal">java.lang.Runnable</code> then the corresponding <code class="literal">run</code>
method is executed.  (This is done <span class="emphasis"><em>after</em></span> the instance is
registered so that cycles can be handled.)  These actions (creating,
registering, and running the module instance) are done both at compile
time and at run time, if necessary.
</p>
        <p>All the imported fields of the module class are then incorporated
in the current set of local visible names in the current module.
(This is for both instance and static modules.)
This is done at compile time - no new bindings are created at run-time
(except for the magic binding used to register the module instance),
and the imported bindings are private to the current module.
References to the imported bindings will be compiled as field
references, using the module instance (except for static fields).
</p>
      </section>
    </section>
    <footer>
      <div class="navfooter">
        <ul>
          <li>
            <b class="toc">
              <a href="Importing.xhtml#idm139667871273696">Searching for modules</a>
            </b>
          </li>
          <li>
            <b class="toc">
              <a href="Importing.xhtml#idm139667871262528">Searching for source files</a>
            </b>
          </li>
          <li>
            <b class="toc">
              <a href="Importing.xhtml#idm139667871238240">Builtin libraries</a>
            </b>
          </li>
          <li>
            <b class="toc">
              <a href="Importing.xhtml#idm139667871212272">Importing a SRFI library</a>
            </b>
          </li>
          <li>
            <b class="toc">
              <a href="Importing.xhtml#idm139667871206048">Importing from a plain class</a>
            </b>
          </li>
        </ul>
        <p>
          Up: <a accesskey="u" href="Objects-Classes-and-Modules.xhtml">Object, Classes and Modules</a></p>
        <p>
        Previous: <a accesskey="p" href="Module-classes.xhtml">Modules and how they are compiled to classes</a></p>
        <p>
        Next: <a accesskey="n" href="Record-types.xhtml">Record types</a></p>
      </div>
    </footer>
  </body>
</html>
