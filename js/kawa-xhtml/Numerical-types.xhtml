<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg">
  <head>
    <title>Numerical types</title>
    <link rel="stylesheet" type="text/css" href="docbook-epub.css"/>
    <link rel="stylesheet" type="text/css" href="kawa.css"/>
    <script src="kawa-ebook.js" type="text/javascript"/>
    <meta name="generator" content="DocBook XSL-NS Stylesheets V1.79.1"/>
    <link rel="prev" href="Numbers.xhtml" title="Quantities and Numbers"/>
    <link rel="next" href="Arithmetic-operations.xhtml" title="Arithmetic operations"/>
  </head>
  <body>
    <header/>
    <section class="sect1" title="Numerical types" epub:type="subchapter" id="Numerical-types">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both">Numerical types</h2>
          </div>
        </div>
      </div>
      <p>Mathematically, numbers are arranged into a tower of subtypes
in which each level is a subset of the level before it:
number; complex number; real number; rational number; integer.
</p>
      <p>For example, <code class="literal">3</code> is an integer. Therefore <code class="literal">3</code> is also a rational,
a real, and a complex number. The same is true of the
Scheme numbers that model 3. For Scheme numbers, these
types are defined by the predicates <code class="literal">number?</code>, <code class="literal">complex?</code>,
<code class="literal">real?</code>, <code class="literal">rational?</code>, and <code class="literal">integer?</code>.
</p>
      <p>There is no simple relationship between a number’s type
and its representation inside a computer. Although most
implementations of Scheme will offer at least two different
representations of 3, these different representations denote
the same integer.
</p>
      <p>Scheme’s numerical operations treat numbers as abstract
data, as independent of their representation as possible.
Although an implementation of Scheme may use multiple
internal representations of numbers, this ought not to be
apparent to a casual programmer writing simple programs.
</p>
      <p class="synopsis" kind="Type"><span class="kind">Type</span><span class="ignore">: </span><a id="idm139667877211856" class="indexterm"/> <code class="function">number</code></p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <p>The type of Scheme numbers.
</p>
        </blockquote>
      </div>
      <p class="synopsis" kind="Type"><span class="kind">Type</span><span class="ignore">: </span><a id="idm139667877208880" class="indexterm"/> <code class="function">quantity</code></p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <p>The type of quantities optionally with units.
This is a sub-type of <code class="literal">number</code>.
</p>
        </blockquote>
      </div>
      <p class="synopsis" kind="Type"><span class="kind">Type</span><span class="ignore">: </span><a id="idm139667877205456" class="indexterm"/> <code class="function">complex</code></p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <p>The type of complex numbers.
This is a sub-type of <code class="literal">quantity</code>.
</p>
        </blockquote>
      </div>
      <p class="synopsis" kind="Type"><span class="kind">Type</span><span class="ignore">: </span><a id="idm139667877202048" class="indexterm"/> <code class="function">real</code></p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <p>The type of real numbers.
This is a sub-type of <code class="literal">complex</code>.
</p>
        </blockquote>
      </div>
      <p class="synopsis" kind="Type"><span class="kind">Type</span><span class="ignore">: </span><a id="idm139667877198640" class="indexterm"/> <code class="function">rational</code></p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <p>The type of exact rational numbers.
This is a sub-type of <code class="literal">real</code>.
</p>
        </blockquote>
      </div>
      <p class="synopsis" kind="Type"><span class="kind">Type</span><span class="ignore">: </span><a id="idm139667877195216" class="indexterm"/> <code class="function">integer</code></p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <p>The type of exact Scheme integers.
This is a sub-type of <code class="literal">rational</code>.
</p>
        </blockquote>
      </div>
      <p>Kawa allows working with expressions of “primitive” types,
which are supported by the JVM without object allocation,
and using builtin arithmetic.  Using these types may be much
faster, assuming the compiler is able to infer
that the variable or expression has primitive type.
</p>
      <p class="synopsis" kind="Type"><span class="kind">Type</span><span class="ignore">: </span><a id="idm139667877190768" class="indexterm"/> <code class="function">long</code></p>
      <p class="synopsis" kind="Type"><span class="kind">Type</span><span class="ignore">: </span><a id="idm139667877188352" class="indexterm"/> <code class="function">int</code></p>
      <p class="synopsis" kind="Type"><span class="kind">Type</span><span class="ignore">: </span><a id="idm139667877186000" class="indexterm"/> <code class="function">short</code></p>
      <p class="synopsis" kind="Type"><span class="kind">Type</span><span class="ignore">: </span><a id="idm139667877183584" class="indexterm"/> <code class="function">byte</code></p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <p>These are fixed-sized primitive signed exact integer types,
of respectively 64, 32, 18, and 8 bits.
If a value of one of these types needs to be converted to an
object, the standard classes <code class="literal">java.lang.Long</code>, <code class="literal">java.lang.Integer</code>,
<code class="literal">java.lang.Short</code>, or <code class="literal">java.lang.Byte</code>, respectively, are used.
</p>
        </blockquote>
      </div>
      <p class="synopsis" kind="Type"><span class="kind">Type</span><span class="ignore">: </span><a id="idm139667877178704" class="indexterm"/> <code class="function">ulong</code></p>
      <p class="synopsis" kind="Type"><span class="kind">Type</span><span class="ignore">: </span><a id="idm139667877176288" class="indexterm"/> <code class="function">uint</code></p>
      <p class="synopsis" kind="Type"><span class="kind">Type</span><span class="ignore">: </span><a id="idm139667877173872" class="indexterm"/> <code class="function">ushort</code></p>
      <p class="synopsis" kind="Type"><span class="kind">Type</span><span class="ignore">: </span><a id="idm139667877171456" class="indexterm"/> <code class="function">ubyte</code></p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <p>These are fixed-sized primitive unsigned exact integer types,
of respectively 64, 32, 18, and 8 bits.
These are presented at runtime using the corresponding
signed types (<code class="literal">long</code>, <code class="literal">int</code>, <code class="literal">short</code>, or <code class="literal">byte</code>).
However, for arithmetic the Kawa compiler generates code to perform the
“mathematically correct” result, truncated to an unsigned result
rather than signed.
If a value of one of these types needs to be converted to an
object, the classes <code class="literal">gnu.math.ULong</code>, <code class="literal">gnu.math.UInt</code>,
<code class="literal">gnu.math.UShort</code>, or  <code class="literal">gnu.math.UByte</code> is used.
</p>
        </blockquote>
      </div>
      <p class="synopsis" kind="Type"><span class="kind">Type</span><span class="ignore">: </span><a id="idm139667877164336" class="indexterm"/> <code class="function">double</code></p>
      <p class="synopsis" kind="Type"><span class="kind">Type</span><span class="ignore">: </span><a id="idm139667877161920" class="indexterm"/> <code class="function">float</code></p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <p>These are fixed-size primitive inexact floating-point real types,
using the standard 64-bit or 32-bit IEEE representation.
If a value of one of these types needs to be converted to an
object, the standard classes <code class="literal">java.lang.Double</code>,
or <code class="literal">java.lang.Float</code> is used.
</p>
        </blockquote>
      </div>
      <section class="sect2" title="Exactness" epub:type="division" id="idm139667877158000">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title">Exactness</h3>
            </div>
          </div>
        </div>
        <a id="idm139667877157056" class="indexterm"/>
        <p>It is useful to distinguish between numbers that are represented
exactly and those that might not be. For example,
indexes into data structures must be known exactly, as
must some polynomial coefficients in a symbolic algebra
system. On the other hand, the results of measurements
are inherently inexact, and irrational numbers may be approximated
by rational and therefore inexact approximations.
In order to catch uses of inexact numbers where exact numbers
are required, Scheme explicitly distinguishes
exact from inexact numbers. This distinction is orthogonal
to the dimension of type.
</p>
        <a id="idm139667877155280" class="indexterm"/>
        <a id="idm139667877154496" class="indexterm"/>
        <p>A Scheme number is <em class="firstterm">exact</em> if it was written as an exact
constant or was derived from exact numbers using only exact operations.
A number is <em class="firstterm">inexact</em> if it was written as
an inexact constant, if it was derived using inexact ingredients,
or if it was derived using inexact operations. Thus
inexactness is a contagious property of a number.
In particular, an <em class="firstterm">exact complex number</em> has an exact real part
and an exact imaginary part; all other complex numbers
are <em class="firstterm">inexact complex numbers</em>.
</p>
        <p>If two implementations produce exact results for a computation
that did not involve inexact intermediate results, the
two ultimate results will be mathematically equal. This
is generally not true of computations involving inexact
numbers since approximate methods such as floating-point
arithmetic may be used, but it is the duty of the implementation
to make the result as close as practical to the
mathematically ideal result.
</p>
        <p>Rational operations such as <code class="literal">+</code> should always produce exact
results when given exact arguments. If the operation
is unable to produce an exact result, then it may either
report the violation of an implementation restriction or it
may silently coerce its result to an inexact value.
</p>
        <p>Except for <code class="literal">exact</code>, the operations described in this section
must generally return inexact results when given any inexact arguments.
An operation may, however, return an
exact result if it can prove that the value of the result is
unaffected by the inexactness of its arguments. For example,
multiplication of any number by an exact zero may
produce an exact zero result, even if the other argument is inexact.
</p>
        <p>Specifically, the expression <code class="literal">(* 0 +inf.0)</code> may return <code class="literal">0</code>,
or <code class="literal">+nan.0</code>, or report that inexact numbers are not supported,
or report that non-rational real numbers are not supported,
or fail silently or noisily in other implementation-specific ways.
</p>
        <p>The procedures listed below will always return exact integer
results provided all their arguments are exact integers
and the mathematically expected results are representable
as exact integers within the implementation:
<code class="literal">-</code>,
<code class="literal">*</code>,
<code class="literal">+</code>,
<code class="literal">abs</code>,
<code class="literal">ceiling</code>,
<code class="literal">denominator</code>,
<code class="literal">exact-integer-sqrt</code>,
<code class="literal">expt</code>,
<code class="literal">floor</code>,
<code class="literal">floor/</code>,
<code class="literal">floor-quotient</code>,
<code class="literal">floor-remainder</code>,
<code class="literal">gcd</code>,
<code class="literal">lcm</code>,
<code class="literal">max</code>,
<code class="literal">min</code>,
<code class="literal">modulo</code>,
<code class="literal">numerator</code>,
<code class="literal">quotient</code>,
<code class="literal">rationalize</code>,
<code class="literal">remainder</code>,
<code class="literal">square</code>,
<code class="literal">truncate</code>,
<code class="literal">truncate/</code>,
<code class="literal">truncate-quotient</code>,
<code class="literal">truncate-remainder</code>.
</p>
      </section>
      <section class="sect2" title="Numerical promotion and conversion" epub:type="division" id="idm139667877134800">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title">Numerical promotion and conversion</h3>
            </div>
          </div>
        </div>
        <p>When combining two values of different numeric types,
the values are converted to the first line in the following
that subsumes (follows) both types.  The computation is done using
values of that type, and so is the result.
For example adding a <code class="literal">long</code> and a <code class="literal">float</code> converts the former
to the latter, yielding a <code class="literal">float</code>.
</p>
        <p>Note that <code class="literal">short</code>, <code class="literal">byte</code>, <code class="literal">ushort</code>, <code class="literal">ubyte</code>
are converted to <code class="literal">int</code> regardless, even in the case of
a single-operand operation, such as unary negation.
Another exception is trancendental functions (such as <code class="literal">cos</code>),
where integer operands are converted to <code class="literal">double</code>.
</p>
        <div class="itemizedlist" epub:type="list">
          <ul class="itemizedlist" style="list-style-type: disc; ">
            <li class="listitem" epub:type="list-item">
              <p><code class="literal">int</code> subsumes <code class="literal">short</code>, <code class="literal">byte</code>, <code class="literal">ushort</code>, <code class="literal">ubyte</code>.
</p>
            </li>
            <li class="listitem" epub:type="list-item">
              <p><code class="literal">uint</code>
</p>
            </li>
            <li class="listitem" epub:type="list-item">
              <p><code class="literal">long</code>
</p>
            </li>
            <li class="listitem" epub:type="list-item">
              <p><code class="literal">ulong</code>
</p>
            </li>
            <li class="listitem" epub:type="list-item">
              <p><code class="literal">java.lang.BigInteger</code>
</p>
            </li>
            <li class="listitem" epub:type="list-item">
              <p><code class="literal">integer</code> (i.e. <code class="literal">gnu.math.IntNum</code>)
</p>
            </li>
            <li class="listitem" epub:type="list-item">
              <p><code class="literal">rational</code> (i.e. <code class="literal">gnu.math.RatNum</code>)
</p>
            </li>
            <li class="listitem" epub:type="list-item">
              <p><code class="literal">float</code>
</p>
            </li>
            <li class="listitem" epub:type="list-item">
              <p><code class="literal">double</code>
</p>
            </li>
            <li class="listitem" epub:type="list-item">
              <p><code class="literal">gnu.math.FloNum</code>
</p>
            </li>
            <li class="listitem" epub:type="list-item">
              <p><code class="literal">real</code> (i.e. <code class="literal">gnu.math.RealNum</code>)
</p>
            </li>
            <li class="listitem" epub:type="list-item">
              <p><code class="literal">number</code>
</p>
            </li>
            <li class="listitem" epub:type="list-item">
              <p><code class="literal">complex</code>
</p>
            </li>
            <li class="listitem" epub:type="list-item">
              <p><code class="literal">quantity</code>
</p>
            </li>
          </ul>
        </div>
        <p>When comparing a primitive signed integer value with a primitive unsigned
integer (for example <code class="literal">&lt;</code> applied to a <code class="literal">int</code> and a <code class="literal">ulong</code>)
the mathemically correct result is computed, as it converting both
operands to <code class="literal">integer</code>.
</p>
      </section>
    </section>
    <footer>
      <div class="navfooter">
        <ul>
          <li>
            <b class="toc">
              <a href="Numerical-types.xhtml#idm139667877158000">Exactness</a>
            </b>
          </li>
          <li>
            <b class="toc">
              <a href="Numerical-types.xhtml#idm139667877134800">Numerical promotion and conversion</a>
            </b>
          </li>
        </ul>
        <p>
          Up: <a accesskey="u" href="Numbers.xhtml">Quantities and Numbers</a></p>
        <p>
        Next: <a accesskey="n" href="Arithmetic-operations.xhtml">Arithmetic operations</a></p>
      </div>
    </footer>
  </body>
</html>
