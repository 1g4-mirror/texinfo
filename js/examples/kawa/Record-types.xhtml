<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg">
  <head>
    <title>Record types</title>
    <link rel="stylesheet" type="text/css" href="docbook-epub.css"/>
    <link rel="stylesheet" type="text/css" href="kawa.css"/>
    <script src="kawa-ebook.js" type="text/javascript"/>
    <meta name="generator" content="DocBook XSL-NS Stylesheets V1.79.1"/>
    <link rel="prev" href="Overall-Index.xhtml" title="Index"/>
    <link rel="next" href="Dynamic-records.xhtml" title="Creating New Record Types On-the-fly"/>
  </head>
  <body>
    <header/>
    <section class="sect1" title="Record types" epub:type="subchapter" id="Record-types">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both">Record types</h2>
          </div>
        </div>
      </div>
      <p>The <code class="literal">define-record-type</code> form can be used for creating new data
types, called record types. A predicate, constructor, and field
accessors and modifiers are defined for each record type.
The <code class="literal">define-record-type</code> feature is specified
by <a class="ulink" href="http://srfi.schemers.org/srfi-9/srfi-9.html" target="_top">SRFI-9</a>,
which is implemented by many modern Scheme implementations.
</p>
      <p class="synopsis" kind="Syntax"><span class="kind">Syntax</span><span class="ignore">: </span><a id="idm139667871195440" class="indexterm"/> <code class="function">define-record-type</code> <em class="replaceable"><code><em class="replaceable"><code>type-name</code></em></code></em> (<em class="replaceable"><code><em class="replaceable"><code>constructor-name</code></em></code></em> <em class="replaceable"><code><em class="replaceable"><code>field-tag</code></em></code></em> <em class="replaceable"><code>...</code></em>) <em class="replaceable"><code><em class="replaceable"><code>predicate-name</code></em></code></em> (<em class="replaceable"><code><em class="replaceable"><code>field-tag</code></em></code></em> <em class="replaceable"><code><em class="replaceable"><code>accessor-name</code></em></code></em> [<em class="replaceable"><code><em class="replaceable"><code>modifier-name</code></em></code></em>]) <em class="replaceable"><code>...</code></em></p>
      <div class="blockquote">
        <blockquote class="blockquote">
          <p>The form <code class="literal">define-record-type</code> is generative: each use creates a new
record type that is distinct from all existing types, including other
record types and Scheme’s predefined types. Record-type definitions may
only occur at top-level (there are two possible semantics for ‘internal’
record-type definitions, generative and nongenerative, and no consensus
as to which is better).
</p>
          <p>An instance of <code class="literal">define-record-type</code> is equivalent to the following definitions:
</p>
          <div class="itemizedlist" epub:type="list">
            <ul style="list-style-type: disc; " class="itemizedlist">
              <li class="listitem" epub:type="list-item">
                <p>The <em class="replaceable"><code>type-name</code></em> is bound to a representation of the record type
itself.
</p>
              </li>
              <li class="listitem" epub:type="list-item">
                <p>The <em class="replaceable"><code>constructor-name</code></em> is bound to a procedure that takes
as many arguments as there are <em class="replaceable"><code>field-tag</code></em>s in the
<code class="literal">(<em class="replaceable"><code>constructor-name</code></em> ...)</code> subform and returns
a new <em class="replaceable"><code>type-name</code></em> record. Fields whose tags are listed with
<em class="replaceable"><code>constructor-name</code></em> have the corresponding argument as their initial
value. The initial values of all other fields are unspecified.
</p>
              </li>
              <li class="listitem" epub:type="list-item">
                <p>The <em class="replaceable"><code>predicate-name</code></em> is a predicate that returns <code class="literal">#t</code>
when given a value returned by <em class="replaceable"><code>constructor-name</code></em>
and <code class="literal">#f</code> for everything else.
</p>
              </li>
              <li class="listitem" epub:type="list-item">
                <p>Each <em class="replaceable"><code>accessor-name</code></em> is a procedure that takes a record of
type <em class="replaceable"><code>type-name</code></em> and returns the current value of the corresponding field.
It is an error to pass an accessor a value which is not a record of the
appropriate type.
</p>
              </li>
              <li class="listitem" epub:type="list-item">
                <p>Each <em class="replaceable"><code>modifier-name</code></em> is a procedure that takes a record of
type <em class="replaceable"><code>type-name</code></em> and a value which becomes the new value of
the corresponding field.
The result (in Kawa) is the empty value <code class="literal">#!void</code>.
It is an error to pass a
modifier a first argument which is not a record of the appropriate type.
</p>
              </li>
            </ul>
          </div>
          <p>Set!ing the value of any of these identifiers has no effect on the
behavior of any of their original values.
</p>
        </blockquote>
      </div>
      <p>Here is an example of how you can define a record type named <code class="literal">pare</code>
with two fields <code class="literal">x</code> and <code class="literal">y</code>:
</p>
      <pre class="screen">(define-record-type pare
  (kons x y)
  pare?
  (x kar set-kar!)
  (y kdr))
</pre>
      <p>The above defines <code class="literal">kons</code> to be a constructor,
<code class="literal">kar</code> and <code class="literal">kdr</code> to be accessors,
<code class="literal">set-kar!</code> to be a modifier,
and <code class="literal">pare?</code> to be a predicate for <code class="literal">pare</code>s.
</p>
      <pre class="screen">(pare? (kons 1 2))        ⇒ #t
(pare? (cons 1 2))        ⇒ #f
(kar (kons 1 2))          ⇒ 1
(kdr (kons 1 2))          ⇒ 2
(let ((k (kons 1 2)))
  (set-kar! k 3)
  (kar k))                ⇒ 3
</pre>
      <p>Kawa compiles the record type into a nested class.
If the <code class="literal">define-record-type</code> appears at module level,
the result is a class that is a member of the module class.
For example if the above <code class="literal">pare</code> class is define in a
module <code class="literal">parelib</code>, then the result is a class
named <code class="literal">pare</code> with the internal JVM name <code class="literal">parelib$pare</code>.
The <code class="literal">define-record-type</code> can appear inside a procedure,
in which case the result is an inner class.
</p>
      <p>The nested class has a name derived from
the <em class="replaceable"><code>type-name</code></em>.  If the <em class="replaceable"><code>type-name</code></em> is valid Java class name,
that becomes the name of the Java class.  If the <em class="replaceable"><code>type-name</code></em> has
the form <code class="literal">&lt;<em class="replaceable"><code>name</code></em>&gt;</code> (for example <code class="literal">&lt;pare&gt;</code>), then <em class="replaceable"><code>name</code></em>
is used, if possible, for the Java class name.  Otherwise, the name
of the Java class is derived by "mangling" the <em class="replaceable"><code>type-name</code></em>.
In any case, the package is the same as that of the surrounding module.
</p>
      <p>Kawa generates efficient code for the resulting functions,
without needing to use run-time reflection.
</p>
    </section>
    <footer>
      <div class="navfooter">
        <p>
          Up: <a accesskey="u" href="Objects-Classes-and-Modules.xhtml">Object, Classes and Modules</a></p>
        <p>
        Previous: <a accesskey="p" href="Importing.xhtml">Importing from a library</a></p>
        <p>
        Next: <a accesskey="n" href="Dynamic-records.xhtml">Creating New Record Types On-the-fly</a></p>
      </div>
    </footer>
  </body>
</html>
